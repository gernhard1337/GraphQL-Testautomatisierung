\section{GraphQL}

GraphQL ist eine Open-Source Query-Language (Abfragesprache) und Laufzeitumgebung die von Facebook entwickelt wurde. (vgl. GraphQL-Spec)
Die Besonderheiten von GraphQL sind, dass man mit nur einer einzelnen Anfrage mehrere Ressourcen gleichzeitig abfragen kann und die
Daten in diesem Schema stark durch einen Typgraphen definiert sind. So lässt sich einerseits die Effizienz stark erhöhen indem weniger Anfragen
gestellt werden die zeitgleich eine höhere Informationsdichte haben.
Außerdem erleichtert GraphQL die Kommunikation von Schnittstellen indem die geünschten Felder schon in der Query definiert werden
und direkt den erwarteten Datentyp zusichern.
Hier liegt auch der große Vorteil im Vergleich zum direkten technologischen Konkurenten REST API.
Bei REST-APIs sind nämlich für verschiedene Ressourcen auch jeweils eine eigene Anfrage nötig und die Typsicherheit ist nicht so stark gegeben
wie bei GraphQL-APIs.
Diese beiden großen Vorteile sorgen dafür, dass GraphQL an Popularität gewinnt und zunehmend eingesetzt wird.
Im Kontext dieser Arbeit ist ein tiefgreifendes, technologisches Verständniss von GraphQL essentiell, deshalb wird hier
eine tiefgreifende Erklärung von GraphQL folgen.

\subsection{Schema \& Typen}

Grundlage einer jeden GraphQL-API ist ein GraphQL-Schema.
Dieses Schema definiert genau wie die Daten der API aufgebaut sind und welche Informationen exisitieren.
Ein GraphQL-Schema ist eine Sammlung von Typen.
Typen sind Objekte einer Datenstruktur.
Ein Typ definiert alle Informationen über sich, hierbei wird für jede Information ein Feld angelegt.
Das Feld kann entweder ein Standarddatentyp wie String, Integer etc. sein oder ein anderer Typ.
Falls das Feld ein anderer Typ ist, so entspricht diese Beziehung einer Kante in einem Graphen.
Dies bedeuet, dass eine Abfrage dieses Feldes dann ein Objekt des Types zurückliefert und hier auch die gewünschten Felder
definiert werden müssen.
Ein sehr einfaches Schema wäre zum Beispiel die Beziehung zwischen Büchern und Authoren.
Ein Buch hat hierbei einen Titel und einen Author.
Ein Author hat einen Namen und ein Geburtsdatum.
Ein Schema für dieses Beispiel sähe wie folgt aus:

\begin{center}
    \begin{verbatim}
        type Buch {
            title: String
            author: Author
        }
        type Author{
            name: String
            geburtsdatum: Date
        }
    \end{verbatim}
\end{center}

Es lässt sich also festhalten, dass ein GraphQL-Typ immer als ein Tupel \verb+(Name, Felder)+ definiert wird wobei
die Felder eine Liste an Tupeln \verb+(Feldname, Feldtyp, Datentyp)+ sind.
Hierbei gelten folgende Einschränkungen für die Elemente des Tupels:

\begin{center}
    \begin{itemize}
        \item[Feldname] ein eindeutiger Feldbezeichner
        \item[Feldtyp] gibt Einschänkungen vor, z.B. nicht Null (durch \verb+!+), Listentyp (durch \verb+[]+) etc.
        \item[Datentyp] der explizite Typ den das Feld hat, kann Standarddatentyp oder anders definierter Type sein
    \end{itemize}
\end{center}

Wenn ein Typ ein Feld enthält, das kein Standarddatentyp ist so entspricht dieses Feld einer Kante in einem Graphen.
Dieses Feld muss dann in einer Query näher definiert werden indem angegeben wird, welche Felder nun vom Typ zu dem die
Kante führt, ausgegeben werden sollen.

\subsection{vordefinierte Typen}

Jedes GraphQL-Schema definiert intial mehrere Typen die spezielle Aufgaben haben und nicht vom User überschrieben werden können.
Im folgenden werden wir auf einige wichtige dieser Typen eingehen.

\subsubsection{Scalar-Types}

Grundlegende Datentypen (Standarddatentypen) werden durch Scalar Types ausgedrückt. Scalar-Types repräsentieren einzelne Werte
wie z.B. einen Integer, einen String, Boolean Werte oder auch Datumstypen.
Ein Scalar-Type kann nicht vom User geändert werden und enthält auch keine anderen Typen (im Gegensatz zu Objekttypen die das können).
Es ist möglich auch eigene Scalar-Types festzulegen jedoch sind in der offiziellen Spezifikation von GraphQL
lediglich folgende Scalar-Types definiert:

\begin{center}
    \begin{itemize}
        \item[Int] 32-bit Integer
        \item[Float] Gleitkommazahl nach IEEE 754
        \item[String] frei wählbarer Text (leerer String zählt nich als non-Null!)
        \item[Boolean] True;False repräsentiert durch internen boolean-type. Ansonsten 0 & 1
        \item[ID] einzigartiger Identifier, intern behandelt wie ein String
        \item[Scalar Extensions] Rohkonstrukt von dem geerbt werden kann für eigen definierte Typen
    \end{itemize}
    (vgl. GraphQL-Sepzifikation 3.5)
\end{center}

\subsubsection{Query-Type}

Der Query-Type definiert alle erlaubten Anfragen (Leseoperationen) an die GraphQL-API.
Hierbei können Anfragen mit und ohne Eingabeparameter angegeben werden.
Die definierten Anfragen haben, wie jeder Typ, einen eindeutigen Bezeichner, welcher dann auch in der zustellenden Query
benutzt wird.
Die Felder der Antwort hängen hierbei vom Feldtypen ab. Ist das Ergebnis der Query-Definition ein Standarddatentyp, so wird
es direkt ausgegeben. Ist es ein anderer definierter Typ, so müss näher bestimmt werden welche Felder erwartet werden.
Nutzen wir das Beispiel der Bücher & Autoren weiter, könnte man wie folgt einen Query-Type definieren:

\begin{verbatim}
    type Query{
        # returns a List of all Books
        getBooks: [Book]
        # returns one random Book
        getBook: Book
        # returns the Author from a Book Title
        getBookByTitle(String title): Author
    }
\end{verbatim}


\subsubsection{Mutation}

Der Mutation-Type ist das Pendant des Query-Types. Im Mutation-Type werden alle erlaubten Schreiboperationen definiert.
Dies beeinhaltet das Erstellen, Aktualisieren und Löschen von Daten in der GraphQL-API.
Felder im Mutation-Type haben auch immer einen Rückgabewert, Konvention ist es hierbei, die veränderten Objekte zurückzugeben,
sodass der Client als Validierung exakt das Objekt bekommt, welches er sich "gewünscht hat".
Die Operationen die mittels Mutation hervorgerufen werden, werden linear abgearbeitet. So ist es in GraphQL möglich, die
Operationen miteinander zu verknüpfen. Man stelle sich z.B. vor, dass ein User seine Mail ändern will und gleichzeitig noch
seinen Namen. Mit REST wären hier zwei Anfragen nötig, GraphQL kann dies mit einer Anfrage erledigen.
Kehren wir wieder auf unser bisheriges Beispiel zurück, ein Mutationstyp hierfür könnte wie folgt aussehen:

\begin{verbatim}
    type Mutation{
        # erstelle einen Author, return den erstellten Author
        createAuthor(name: String!, birthdate: Date):Author
        # erstelle ein Buch, return das erstellte Buch
        createBok(title: String!, author:Author): Book
        # ändere den Titel eines Buches, return des Buches mit geänderten Titel
        changeBookTitle(title: String! , newTitle: String!): Book
        # ändere den Geburtstag eines Autors, return des geänderten Authors
        changeBirthdateFromAuthor(author: Author!, newBirthDate: Date!)
    }
\end{verbatim}

eine einzelne Mutation kann Pflichtfelder und optionale Felder markieren.
Pflichtfelder werden mit einem \verb+!+ markiert.
Diese Felder müssen dann als Argument bei jeder Ausführung mitgesendet werden.
Optionale Felder benötigen dies nicht.

\subsubsection{Subscription}

Eine Besonderheit von GraphQL ist der Subscription-Type.
Dieser ermöglicht eine Echtzeitkommunikation zwischen Server und Client, indem mithilfe des WebSocket-Protokolls eine
permanente Verbindung zwischen Server und Client hergestellt wird.
Diese permantente Verbindung ermöglicht es dem Server direkt Daten an den Client zu senden ohne, dass der Client dafür
eine Anfrage schicken muss.
Wie auch in allen anderen Typen definiert der Subscription-Type Felder mit einem Namen und Rückgabetyp.
Im Beispiel der Bücher & Autoren wäre hierbei nun denkbar, dass eine Subscription für neue Bücher & neue Autoren wünschenswert
wäre.
Hierdurch folgt dann dieser Subscription-Type:

\begin{verbatim}
    type Subscription{
        # neues Buch veröffentlicht
        newBook: Book
        # ein neuer Author erscheint
        newAuthor: Author
    }
\end{verbatim}

Ein Client könnte sich auf diese Kanäle nun subscriben.
Angenommen, wir wollen immer über ein neues Buch informiert werden so muss der Client diese Anfrage stellen:

\begin{verbatim}
    subscription{
        newBook{
            title
            author{
                name
            }
        }
    }
\end{verbatim}

Hierdurch wird eine permanente Verbindung hergestellt und immer ein Objekt vom Type Book mit den Feldern title \& author gesendet, wenn ein neues erschienen ist.
Es ist wie auch in anderen Typen möglich, Felder wegzulassen falls diese nicht.
Ein spezieller Client muss gewählt werden, der den WebSocket offen lässt, um den die Nachrichten zu empfangen, dies ist
jedoch spezifisch abhängig von dem Projekt (Sprache, gewählte GraphQL Server Instanz).

\subsection{Resolver}

Bisher beschäftigen wir uns vorrangig mit der Strukturierung und Typisierung von GraphQL und den Daten die durch
das GraphQL Schema dargestellt werden.
Ein wichtiger Baustein fehlt aber noch.
Woher kommen die Daten?
Wie werden Eingabedaten behandelt?
Diese Fragen werden durch die Resolver beantwortet.
Ein Resolver ist in GraphQL eine Funktion die zuständig für die Datenabfragen und Strukturierung ist.
Im Schema haben wir bisher definiert in welcher Art und Weise wir die Daten haben wollen, der Resolver ist nun dafür zuständig,
diese Daten im definierten Format zur Verfügung zu stellen.
Die Resolver sind nicht, wie alle vorher benannten Teil von GraphQL offen einsehbar, sondern sind Funktionen einer Programmiersprache.
Für jedes Feld im Schema, das Daten enthält, muss ein Resolver implementiert werden, dies umfasst insbesondere die Query, Mutation und Subscription Typen aber auch
alle selbstdefinierten Typen.
Die konkrete Implementierung der Resolver hängt von verschiedenen Dingen ab, insbesondere jedoch welchen GraphQL-Server man nutzt und welche Programmiersprache verwandt wird.
Ein beispielhafter Resolver für die Query eines Buches anhand seines Titels mit ApolloServer in Javascript könnte folgende minimale Syntax haben:

\begin{verbatim}
    const resolvers = {
        Query: {
            book: (parent, args, context, info) => {
                return getBookByID(args.id);
            },
        },
    };
\end{verbatim}

Wobei hierbei zu beachten sei, dass alle Argumente die mitgegeben werden im \verb+args+ Argument gespeichert sind.
Die Funktion getBookByID gibt ein, dem Schema entsprechendes, Json-Objekt zurück.
Da die Resolver konkrete Implementierungen außerhalb von GraphQL sind und die einzelnen Resolver untereinander aufrufen können, bedarf es hier
einer Reihe an Tests da dieser Code gerne Fehlerhaft sein kann.
Ein Klassiker für GraphQL ist es, einzelne Attribute in einem Resolver zu vergessen.
Ein Entwickler sollte für jeden Resolver, der ja eine Funktion darstellt, Unit-Tests zur Verfügung stellen.
Da sich die einzelnen Resolver aber auch untereinander aufrufen können, muss hier auch die Integrität getestet werden.
Hier setzten wir an, indem unsere Testgenerierung darauf aufbaut, jeden möglichen Resolver in mindestens einer Kombination mit anderen Resolvern zu testen.
So kann sichergestellt werden, dass die Resolver untereinander integer sind.







