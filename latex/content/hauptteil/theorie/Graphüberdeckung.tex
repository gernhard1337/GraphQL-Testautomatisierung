\chapter{Graphcoverage}

Wie zuvor gesehen, existieren verschiedene Coverage-Kriterien um Testabdeckung zu prüfen.
Graphcoverage ist hierbei eine Herangehensweise um graphenbasierte Datenstrukturen zu überdecken.
Graphen können nämlich ähnliche Probleme aufweisen wie vorheriges Beispiel der Addition.
Die Addition zweier 64-bit Integer ist wenigstens endlich, Graphenstrukturen haben sogar unter Umständen unendliche Testräume.
Umso wichtiger ist es hier, dass Überdeckungskriterien formuliert werden können, die diesen möglicherweise unendlichen Suchraum
stark verkleinern und dennoch eine ausreichende Testung ermöglichen.
Da wir vorher ergründet haben, dass GraphQL sich als gerichteten Graph darstellen lässt, können wir nun die Graphcoverage nutzen, um Tests mithilfe der Grapcoverage zu erstellen.
Wie genau die Coverage erstellt wird und daraus Tests resultieren, werden im folgenden geklärt.
Gerichtete Graphen sind die Grundlage für viele Coverage-kriterien, wobei die Grundidee hierbei ist,
Sachverhalte als Graphen zu modellieren und dann eine ausreichende Überdeckung zu finden. \cite[vgl. Software-testing S. 27 2.1]{software-testing}
In $4.1.2$ wurden gerichtete Graphen bereits eingeführt, daher können wir direkt fortfahren und verschiedene
Kriterien definieren, die einen Graphen überdecken.
Wir erklären zuerst verschiedene Techniken, die einen Graphen überdecken und erklären dann ihre Anwendung
an Beispielen.
Erst sortieren wir Graphcoverage ein im Kontext von Code-Coverage und bilden im zweiten Schritt eine Coverage für GraphQL\@.

\section{Graphcoverage allgemein}

Um Graphcoverage zu nutzen, verfeinern wir zuerst die allgemeine Definition von gerichteten Graphen.
Ein gerichteter Graph ist ein Paar $G = (V, E)$ zweier disjunkter Mengen mit $E \subseteq V^2$ wobei alle Elemente aus E gerichtete Kanten sind. [vgl. 4.1.2]
Die Definition erweitern wir nun mit:

\begin{description}
    \item[Menge N] von Knoten
    \item[Menge N_{0}] von Anfangsknoten, wobei N_{0} $\subseteq$ N
    \item[Menge N_{f}] von Endknoten, wobei N_{f} $\subseteq$ N
    \item[Menge E] von Kanten, wobei E $\subseteq$ N x N. Hierbei ist die Menge als init{x} x target{y} definiert.
\end{description}~\cite[2.1 Overview]{software-testing}

Mithilfe dieser Definition können nun zum Beispiel Kontrollflussgraphen abgebildet werden indem die Einstiegspunkte die Anfangsknoten sind und die Endknoten die Austrittspunkte.
Ein Pfad innerhalb von eben definierten Graphen, mit möglicher Länge Null, der in einem Knoten $N_{0}$ startet und in einem Knoten $N_{f}$ endet, nennt sich Testpfad \cite[vgl. S. 28]{software-testing}
Ziel ist es nun mit hilfe von Coverage-Kriterien Testpfade zu ermitteln die unser Problem ausreichend testen - was hierbei ausreichend ist, ist von Fall zu Fall unterschiedlich.

\section{Graphcoverage Kriterien}

Mithilfe voriger Definition können wir nun Coveragekriterien entwickeln, die uns Testpfade liefern, die je nach Kriterium für eine spezielle Abdeckung
des Graphens mit Test-Requirements sorgen.

\subsection{Node Coverage}

Node-Coverage ist ein Coveragekriterium, dass alle Knoten, die von $N_{0}$ erreichbar sind, in einem Graphen abdecken soll.
Definieren wir folgenden, sehr einfachen Graphen:

\begin{tikzpicture}
    \node[circle, draw] (n1) at (2,2) {X};
    \node[circle, draw] (n2) at (4,1) {Y};
    \node[circle, draw] (n3) at (2,0) {Z};

    \draw[->] (-1,2) -- node[above] {start} (n1);
    \draw[->] (n1) -- node[above] {x $\le$ 4} (n2);
    \draw[->] (n2) -- (n3);
    \draw[->] (n1) -- node[above] {sonst} (n3);
\end{tikzpicture}

So wäre die Node-Coverage mit einem Test einzigen Test erfüllbar.
Dieser ist der Pfad $X \rightarrow Y \rightarrow Z$.
Es ist auch denkbar, dass wir zwei Pfade oder mehr nutzen allerdings erfüllt dieser Pfad schon unser Kriterium daher geben wir uns vorerst zufrieden.
Wir sehen schnell, dass dieser Ansatz noch Lücken aufweist, da der Pfad $X \rightarrow Y \rightarrow Z$ das Kriterium erfüllt, allerdings wird eine Kante $X \rightarrow Z$ nicht im
Test berücksichtigt und kann somit ungetestet bleiben.
Wir führen also noch andere Kriterien ein, die eher geeignet wären.

\subsection{Edge-Coverage}

Edge-Coverage ist ein Coveragekriterium, dass die Kanten in einem Graphen abdecken soll.
Ziel der Edge-Coverage ist es, dass jede Kante des Graphens durch mindestens einen Test abgedeckt wird.
Um die Edge-Coverage für vorheriges Beispiel zu erreichen, benötigen wir schon zwei Routen.
Der Graph:

\begin{tikzpicture}
    \node[circle, draw] (n1) at (2,2) {X};
    \node[circle, draw] (n2) at (4,1) {Y};
    \node[circle, draw] (n3) at (2,0) {Z};

    \draw[->] (-1,2) -- node[above] {start} (n1);
    \draw[->] (n1) -- node[above] {x $\le$ 4} (n2);
    \draw[->] (n2) -- (n3);
    \draw[->] (n1) -- node[above] {sonst} (n3);
\end{tikzpicture}

wird über die Pfade $X \rightarrow Y \rightarrow Z$ und $X \rightarrow Z$ überdeckt.
Edge-Coverage hat allerdings auch Probleme Graphen vollständig zu überdecken.
Man nehme folgendes Beispiel:

\begin{tikzpicture}
    \node[circle, draw] (a) at (4,4) {A};
    \node[circle, draw] (b) at (4,2) {B};
    \node[circle, draw] (c) at (4,0) {C};

    \draw[->, bend left=30] (a) to node[above] { w } (b);
    \draw[->, bend right=30] (a) to node[above] { x } (b);
    \draw[->, bend left=30] (b) to node[above] { y } (c);
    \draw[->, bend right=30] (b) to node[above] { z } (c);
\end{tikzpicture}

Pfade die laut Edge-Coverage ausreichen um den Graphen zu überdecken wären: \\
$ x \rightarrow z $ \\
$ w \rightarrow y $ \\
Hierbei wird allerdings außer acht gelassen, dass in $x$ auch Änderungen passieren können die Auswirkungen im Programm haben können.
So sind die Routen $ x \rightarrow y $ und $ w \rightarrow z $ in der Edge-Coverage nicht berücksichtigt.
Allerdings wären diese auch zu testen.
Wir sehen also, dass wir immer noch kein ideales Kriterium gefunden haben.


\subsection{Edge-Pair Coverage}

Das Edge-Pair Coveragekriterium ist eine Erweiterung der Edge-Coverage, indem hier auch die Beziehungen von einzelnen Kanten untereinander berücksichtigt werden um das zuvor
aufgetretene Problem zu lösen.
Nach \cite[Introduction to Software Testing]{software-testing} ist Edge-Pair Coverage: ''Alle erreichbaren Pfade von Länge bis zu 2 im Testgraphen''.
Ziel dieses Coverage-Kriteriums ist es, dass alle möglichen Kantenpaare abgedeckt sind.
Eben definiertes Beispiel hätte mit Edge-Pair Coverage eine Überdeckung mit: \\
$ x \rightarrow z $ \\
$ w \rightarrow y $ \\
$ x \rightarrow y $ \\
$ w \rightarrow z $

Dieses simple Beispiel wird durch Edge-Pair Coverage gut abgedeckt.
Edge-Pair Coverage neigt allerdings dazu, extrem große Suchräume zu erzeugen und nur Pfadkombinationen bestimmter Länge zu betrachten. \cite[vgl. S. 35]{software-testing}
Hierdurch werden bestimmte Kombinationen von Pfaden immer noch nicht berücksichtigt.

\begin{tikzpicture}
    \node[circle, draw] (start) at (0,0) {Start};
    \node[circle, draw] (a) at (2,2) {A};
    \node[circle, draw] (b) at (2,-2) {B};
    \node[circle, draw] (c) at (4,0) {C};
    \node[circle, draw] (d) at (6,2) {D};
    \node[circle, draw] (e) at (6,-2) {E};
    \node[circle, draw] (end) at (8,0) {End};

    \draw[->] (start) to node[above] { a } (a);
    \draw[->] (start) to node[above] { b } (b);
    \draw[->] (a) to node[above] { c } (c);
    \draw[->] (b) to node[above] { d } (c);
    \draw[->] (c) to node[above] { e } (d);
    \draw[->] (c) to node[above] { f } (e);
    \draw[->] (d) to node[above] { g } (end);
    \draw[->] (e) to node[above] { h } (end);
    \draw[->] (a) to node[out=30, in=150] { i } (d);
    \draw[->] (b) to node[out=-30, in=210] { j } (e);
\end{tikzpicture}

Nach der Definition von Edge-Pair Coverage ermitteln wir erstmal alle Pfadkombinationen der Länge ''bis zu 2''
Dies wären:

$Start \rightarrow A \rightarrow C$ \\
$Start \rightarrow A \rightarrow D$ \\
$Start \rightarrow B \rightarrow C$ \\
$Start \rightarrow B \rightarrow E$ \\
$A \rightarrow C \rightarrow D$ \\
$A \rightarrow C \rightarrow E$ \\
$B \rightarrow C \rightarrow D$ \\
$B \rightarrow C \rightarrow E$ \\
$A \rightarrow D \rightarrow End$ \\
$B \rightarrow E \rightarrow End$ \\
$C \rightarrow D \rightarrow End$ \\
$C \rightarrow E \rightarrow End$ \\

Hierdurch ergeben sich dann diese Testpfade:

$Start \rightarrow  A \rightarrow  C \rightarrow  D \rightarrow  End$ \\
$Start \rightarrow  A \rightarrow  C \rightarrow  E \rightarrow  End$ \\
$Start \rightarrow  B \rightarrow  C \rightarrow  D \rightarrow  End$ \\
$Start \rightarrow  B \rightarrow  C \rightarrow  E \rightarrow  End$ \\

allerdings fehlen auch hier wieder Pfade. \\
Zum Beispiel der Pfad $Start \rightarrow A \rightarrow D \rightarrow End$ fehlt.
Hierdurch bleiben wieder Teile des Graphens unüberdeckt.

\subsection{Prime-Path Coverage}

Die Prime-Path Coverage verlangt, dass jeder (Prime)Primärpfad durch mindestens einen Testpfad abgedeckt sein muss.
Ein Primärpfad ist definiert als ein einfacher Pfad, der nicht vollständig als zusammenhängender Teil in einem anderen einfachen Pfad enthalten ist. \cite[vgl. S. 35]{software-testing}
Hierbei ist ein einfacher Pfad dann  ein Pfad, in dem keine Kanten und keine Knoten wiederholt werden,
mit Ausnahme möglicherweise des ersten und letzten Knotens (wenn sie gleich sind, handelt es sich um einen Kreis).
In diesem Graphen:

\begin{tikzpicture}
    \node[circle, draw] (start) at (4,4) {Start};
    \node[circle, draw] (a) at (4,2) {A};
    \node[circle, draw] (b) at (6,3) {B};
    \node[circle, draw] (c) at (6,1) {C};
    \node[circle, draw] (d) at (4,0) {End};


    \draw[->] (start) to node[above] { } (a);
    \draw[->] (a) to node[above] { } (b);
    \draw[->] (b) to node[above] { } (c);
    \draw[->] (a) to node[above] { } (d);
    \draw[->] (c) to node[above] { } (a);
\end{tikzpicture}

Sind dies alle Prime-Paths: \\

$ Start \rightarrow  A \rightarrow  End$ \\
$ Start \rightarrow A \rightarrow B \rightarrow C$ \\
$ A \rightarrow B \rightarrow C \rightarrow A $ \\
$ B \rightarrow C \rightarrow A \rightarrow B $ \\
$ C \rightarrow A \rightarrow B \rightarrow C $ \\
$ B \rightarrow C \rightarrow A \rightarrow End $ \\

und schon zwei Testpfade würden ausreichen um die Prime-Path Coverage zu erfüllen.
Die Testpfade die das Testrequirement erfüllen sind:

$Start \rightarrow A \rightarrow End$ \\
$Start \rightarrow A \rightarrow B \rightarrow C \rightarrow A \rightarrow B \rightarrow C \rightarrow A \rightarrow End$

\subsection{Complete-Path Coverage}

Als letztes Coveragekriterium wollen wir die Complete-Path Coverage einführen.
Ziel dieses Coveragekriteriums ist es, dass jeder mögliche Pfad mit einem Test abgedeckt werden kann.
Wir brauchen dieses Kriterium nicht ausführlich definieren, da in zyklischen Graphen eine Complete-Coverage nicht möglich ist.
Kreise in Graphen führen zu einer unendlich großen Menge an Pfaden und wir können keine unendlich große Menge behandeln.
Die Complete-Path Coverage ist sinnvoll wenn wir Kreise verbieten und der Testgraph nicht zu groß ist.
Um unsere Methode jedoch von \cite[Property-based Testing]{property-based-testing} abzugrenzen wollen wir explizit Kreise erlauben.
Ja sogar fördern um zu symbolisieren warum unsere Methode eine Verbesserung darstellt.


\subsection{abschließender Vergleich der Coverage-Kriterien}


\section{Graphcoverage für Code}

\section{Graphcoverage für GraphQL}




