\chapter{Testentwurf}

Der allgemeine Testentwurf besteht aus zwei einzelnen Phasen.
In der ersten Phase wird das GraphQL Schema analysiert und die Prime-Paths generiert.
So haben wir grundlegendes Wissen darüber, welche Querys ausgeführt werden müssen damit jeder Bereich
der API abgedeckt ist.
In der zweiten Phase \ldots

\section{erste Phase / GraphQL Analyse}

Grundlage der Analyse einer GraphQL-API ist ihr Schema.
Die gesamte erste Phase bezieht sich nur auf das Schema denn aus diesem können wir alle grundlegenden
Test-Cases ermitteln die nötig sind um eine Überdeckung der Anfragen zu ermitteln.
Es sei hier gesagt, dass nur die Überdeckung der Anfragen nicht bedeutet, dass die API hiermit vollständig getestet wird,
hierdurch werden nur alle Anfragen erstellt, sodass jeder Knoten und jede Kante im definierten Schema mindestens
einmal Betrachtung findet in einem Test.
Die dahinterliegenden Resolver benötigen weitere Abdeckung hierzu jedoch mehr in Phase 2.

\subsection{GraphQL in Graph übersetzen}

Um ein GraphQL Schema in einen Graphen zu übersetzen, bedarf es mehrerer Schritte.
Im GraphQL Standard implementiert jeder GraphQL-Client eine {\tt parse()} Funktion.
Diese werden wir auch nutzen, da wir hierdurch einen Graphen erhalten der für unsere Berechnungen auf dem
Graphen passend ist.
Die {\tt parse()} Funktion führt im wesentlichen zwei Schritte aus:

\begin{description}
    \item[Lexikalische Analyse] Schema in Token zerlegen
    \item[Syntaktische Analyse] Token in passende Graph-Repräsentation übersetzen
\end{description} (Quelle X.Y.Z)

Endergebnis ist ein Abstract Syntax Tree (AST) (Quelle einfügen).
Ein AST sieht je nach GraphQL-Client Plattform unterschiedlich, jedoch sehr ähnlich aus.
Folgendes, sehr simples Schema:

\begin{verbatim}
    type Query {
      user(id: Int): User
    }

    type User {
      id: Int
      name: String
    }
\end{verbatim}

wird in folgenden AST übersetzt (in Java-/Type-script ist der AST in json Format):

\begin{lstlisting}[language=json,firstnumber=1]
{
  "kind": "Document",
  "definitions": [
    {
      "kind": "ObjectTypeDefinition",
      "name": {
        "kind": "Name",
        "value": "Book"
      },
      "fields": [
        {
          "kind": "FieldDefinition",
          "name": {
            "kind": "Name",
            "value": "id"
          },
          "type": {
            "kind": "NamedType",
            "name": {
              "kind": "Name",
              "value": "Int"
            }
          }
        },
        {
          "kind": "FieldDefinition",
          "name": {
            "kind": "Name",
            "value": "title"
          },
          "type": {
            "kind": "NamedType",
            "name": {
              "kind": "Name",
              "value": "String"
            }
          }
        },
        {
          "kind": "FieldDefinition",
          "name": {
            "kind": "Name",
            "value": "author"
          },
          "type": {
            "kind": "NamedType",
            "name": {
              "kind": "Name",
              "value": "Author"
            }
          }
        }
      ]
    },
    {
      "kind": "ObjectTypeDefinition",
      "name": {
        "kind": "Name",
        "value": "Author"
      },
      "fields": [
        {
          "kind": "FieldDefinition",
          "name": {
            "kind": "Name",
            "value": "id"
          },
          "type": {
            "kind": "NamedType",
            "name": {
              "kind": "Name",
              "value": "Int"
            }
          }
        },
        {
          "kind": "FieldDefinition",
          "name": {
            "kind": "Name",
            "value": "name"
          },
          "type": {
            "kind": "NamedType",
            "name": {
              "kind": "Name",
              "value": "String"
            }
          }
        },
        {
          "kind": "FieldDefinition",
          "name": {
            "kind": "Name",
            "value": "written"
          },
          "type": {
            "kind": "ListType",
            "type": {
              "kind": "NonNullType",
              "type": {
                "kind": "NamedType",
                "name": {
                  "kind": "Name",
                  "value": "Books"
                }
              }
            }
          }
        }
      ]
    }
  ]
}

\end{lstlisting}

Die Ausgabe in diesem AST verrät uns für jede "ObjectTypeDefinition" das wir hier einen Knoten des Graphens haben
und in dem "Fields" eintrag kann man alle möglichen Verbindungen des Knotens finden.

\subsection{Pfadgenerierung}

Da wir im vorherigen Schritt eine geeignete Darstellung gefunden haben, um unseren Graphen zu repräsentieren können wir
nun im ersten Schritt alle Pfade ausgehend vom Querytype innerhalb dieses Graphens finden.
Um die Pfade zu ermitteln müssen wir lediglich wissen, welche Typen ein einzelner Knoten haben kann.
In Kapitel (GraphQL Kapitel verlinken) wurde bereits auf alle möglichen Typen eingegangen.
Hierbei sind für die Pfadgenerierung nur diese wichtig:
\begin{center}
  \begin{description}
    \item[FieldDefiniton]
    \item[NonNullType]
    \item[ListType]
    \item[ObjectTypeDefinition]
  \end{description} (Quelle X.Y.Z)
\end{center}

Aus unserem schon bekannten Schema:

\begin{verbatim}
type Book {
    id: Int
    title: String
    author: Author
}
type Author {
    id: Int
    name: String
    books: [Book]
}
type Query {
    # test query
    hello: String
    # all books
    books: [Book]
    # all authors
    authors: [Author]
    # a single book from a author name
    bookWrittenBy(name: String!): Book
    # all books from a author
    booksWrittenBy(name: String!): [Book]
    # a author for a book title
    writtenBy(title: String!): Author
}
\end{verbatim}

können wir nun beginnen die Pfade zu generieren. Hierbei müssen wir nur Pfade generieren, die ihren
Ursprung im Query Type haben denn andere Typen sind nicht initial abfragbar sondern nur durch Verkettung mit einer
Operation vom Query Type. Jedes Feld vom Query Type ist ein Einstiegspunkt für einen Pfad.
Ein Pfad führt weiter, wenn das Ergebnis eines Pfades eine ObjectTypeDefinition enthält. Also hier dementsprechend
"Author" oder "Book"

Besagtes Schema führt dann zu folgendem Graphen:

\begin{center}
  \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{img/graph-paths}
\end{center}

Ausgehend davon, dass jedes Feld vom Query-Type Ausgangspunkt eines Pfades ist, existieren in Iteration 0 die Pfade:

Iteration 0:

\begin{itemize}
  \item hello
  \item books
  \item authors
  \item bookWrittenBy
  \item booksWrittenBy
  \item writtenBy
\end{itemize}

Iteration 1:

\begin{itemize}
  \item hello
  \item books
  \item books -> author
  \item authors
  \item authors -> books
  \item bookWrittenBy -> author
  \item booksWrittenBy -> author
  \item writtenBy -> book
\end{itemize}

Iteration 2:

\begin{itemize}
  \item hello
  \item books
  \item books -> author
  \item books -> author -> books
  \item authors
  \item authors -> books
  \item authors -> books -> author
  \item bookWrittenBy
  \item bookWrittenBy -> author
  \item bookWrittenBy -> author -> book
  \item booksWrittenBy
  \item booksWrittenBy -> author
  \item booksWrittenBy -> author -> book
  \item writtenBy
  \item writtenBy -> book
  \item writtenBy -> book -> author
\end{itemize}

In Iteration 2 ist nun zu erkennen, dass sich Kreise bilden. Es ist nun möglich weitere Iterationen durchzuführen jedoch
wird hier keine weitere Information mehr gewonnen, denn die nun resultierenden Pfade sind nur Wiederholungen der eben erkannten
Kreise.










\begin{center}
  \begin{description}
    \item[kind]
    \item[name]
    \item[type]
    \item[ObjectTypeDefinition]
  \end{description} (Quelle X.Y.Z)
\end{center}

Mittels folgendem Pseudo-Code ist es dann möglich, alle Pfade zu ermitteln:

\begin{verbatim}
  0. Importiere funktionen buildSchema(), parse() und printSchema()
  1. Lese GraphQL-Schema String
  2. Erstelle AST
  3. pfade = []
  4. Für alle Definitionen im AST mache:
    4.1 Wenn Definition.kind == "ObjectTypeDefinition"
        4.1.1 ermitteltePfade = ermittel alle Pfade ausgehend von diesem Knoten
        4.1.2 pfade[] = ermitteltePfade
    sonst ist Definition BasisDatentyp -> Pfadende
  5. return pfade
\end{verbatim}















































\subsection{Filtern der Prime-Paths}

Da wir nun eine Liste aller möglichen Pfade haben, müssen wir diese nur noch nach PrimePaths filtern.
Wie in (Kapitel verlinken) bereits erwähnt, sind PrimePaths die längsten Pfade, die kein Teilpfad eines anderen Pfades sind.
Hierzu können wir eine einfache Funktion entwickeln, die alle "nicht Prime Paths" herausfiltert.
Diese Funktion muss hierfür jeden errechneten Pfad einmal überprüfen ob dieser Pfad ein Teilpfad eines anderen Pfades ist.
Sollte der Pfad ein Teilpfad sein, so ist dieser kein PrimePath andernfalls handelt es sich um einen PrimePath und
dieser wird behalten. Konkrete Implementierung ist hierfür im Praxis-Teil zu finden (Link zum Kaptitel).

\section{zweite Phase / Pfade untersuchen und tests für resolver entwickeln}